/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package batalla.naval;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import javax.swing.ImageIcon;
import javax.swing.JButton;

/**
 *
 * @author Jose
 */
public class Tablero extends javax.swing.JPanel {

    //Dificultad
    private int DIFICULTY; // 0 = Normal, 1 = Medio, 2=Dificil
    // Tamaño del tablero y espaciado entre celdas
    private int Size;
    private final int Gap = 1;
    private final int ButtonSize = 50;
    private char LAST_LETTER; // Última letra posible en el tablero

    // Indicadores de jugador y estado de construcción
    private boolean isPlayer; // Si es el jugador o enemigo
    private boolean inBuild; // Indica si se está construyendo el tablero

    // Jugadores y elementos del juego
    private Player player; // Jugador actual
    private Player enemy; // Jugador enemigo
    private Boat actualBoat; // Barco actualmente seleccionado
    private Power actualPowerUp; // PowerUp actualmente seleccionado
    private List<String> priorityCellsEnemy = new ArrayList<>(); //Lista de celdas prioritarias del enemigo
    // Lista de botones/elementos gráficos
    private List<JButton> buttons; // Lista de botones

    // Listas de bordes para validación de celdas
    private List<String> borderRight = new ArrayList<>();
    private List<String> borderLeft = new ArrayList<>();
    private List<String> borderTop = new ArrayList<>();
    private List<String> borderButton = new ArrayList<>();

    // Icono para celdas vacías
    private final ImageIcon VOID_CELL = new ImageIcon(System.getProperty("user.dir") + "\\src\\img\\Z.png");

    // Lista de celdas "fantasma" pintadas
    private List<String> ghostCells = new ArrayList<>();

    // Programación de tareas periódicas
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    /**
     * Lista de entidades a usar (barcos y minas) Nota: Las minas deben ir de
     * ultimas: 1 - 3 = Barcos, 0 = Mina
     */
    private List<Integer> entityList = new ArrayList<>();
    private List<Integer> copyOfEntityList = new ArrayList<>();//Lista para copia de la lista de entidades

    /**
     * Constructor de Tablero
     *
     * @param Size Tamaño del tablero
     */
    public Tablero(int Size) {
        // Inicialización de variables
        this.DIFICULTY = 0;
        this.Size = Size; // Tamaño del tablero
        this.LAST_LETTER = (char) ('A' + (Size - 1)); // Última letra en el tablero según el tamaño
        this.isPlayer = true; // Indica si es el turno del jugador
        this.inBuild = true; // Indica si se está construyendo el tablero
        this.buttons = new ArrayList<>(); // Lista de botones y elementos gráficos del tablero

        // Inicialización de jugadores y elementos del juego
        this.player = new Player(); // Jugador actual
        player.setTypeAttack(true); // Tipo de ataque del jugador
        this.actualBoat = new Boat(); // Barco actualmente seleccionado
        this.enemy = new Player("Bot"); // Jugador enemigo
        this.actualPowerUp = null; // PowerUp actualmente seleccionado
        this.entityList = Arrays.asList(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 0, 0, 0); //Entidades disponibles
        // Inicialización de componentes gráficos y de juego
        initComponents(); // Inicializa los componentes gráficos del tablero
        initCells(); // Inicializa las celdas del tablero
        setBorders(); // Define los bordes del tablero para validación de celdas
        // generateCoordsOfBoats(enemy);//Crear tablero del enemigo IA
        changeEntity();//Inicializa la lista de entidades y construccion
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        Panel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        ImageBoat = new javax.swing.JLabel();
        L_Healtd = new javax.swing.JLabel();
        L_Size = new javax.swing.JLabel();
        L_Orientation = new javax.swing.JLabel();
        rotateButton = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        TablePanel = new javax.swing.JPanel();

        jButton1.setText("jButton1");

        setBackground(new java.awt.Color(255, 255, 153));
        setMinimumSize(getDimension());

        Panel.setBackground(new java.awt.Color(255, 255, 255));

        jLabel1.setText("Barco actual:");

        ImageBoat.setIcon(new ImageIcon(urlOfImage("0")));
        ImageBoat.setDebugGraphicsOptions(javax.swing.DebugGraphics.NONE_OPTION);
        ImageBoat.setIconTextGap(0);
        ImageBoat.setMaximumSize(new java.awt.Dimension(150, 150));
        ImageBoat.setMinimumSize(new java.awt.Dimension(150, 150));
        ImageBoat.setPreferredSize(new java.awt.Dimension(150, 150));

        L_Healtd.setText("Vida:");

        L_Size.setText("Tamaño:");

        L_Orientation.setText("Orientación:");

        rotateButton.setText("Rotar");
        rotateButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                rotateButtonMouseClicked(evt);
            }
        });

        jButton2.setText("Posicionar");
        jButton2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jButton2MouseClicked(evt);
            }
        });

        javax.swing.GroupLayout PanelLayout = new javax.swing.GroupLayout(Panel);
        Panel.setLayout(PanelLayout);
        PanelLayout.setHorizontalGroup(
            PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(PanelLayout.createSequentialGroup()
                .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(PanelLayout.createSequentialGroup()
                        .addGap(27, 27, 27)
                        .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(L_Healtd)
                            .addComponent(L_Size)
                            .addComponent(L_Orientation)))
                    .addGroup(PanelLayout.createSequentialGroup()
                        .addGap(17, 17, 17)
                        .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(ImageBoat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(rotateButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jButton2, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE)))))
                .addContainerGap(29, Short.MAX_VALUE))
            .addGroup(PanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        PanelLayout.setVerticalGroup(
            PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(PanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(18, 18, 18)
                .addComponent(ImageBoat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(13, 13, 13)
                .addComponent(L_Healtd)
                .addGap(18, 18, 18)
                .addComponent(L_Size)
                .addGap(18, 18, 18)
                .addComponent(L_Orientation)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(rotateButton, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jButton2)
                .addContainerGap(205, Short.MAX_VALUE))
        );

        TablePanel.setBackground(new java.awt.Color(204, 255, 255));
        TablePanel.setLayout(new java.awt.GridLayout(1, 0));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Panel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(TablePanel, javax.swing.GroupLayout.DEFAULT_SIZE, 596, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(TablePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(Panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    /**
     * Metodo para obtener la ruta de una imagen segun el nombre
     *
     * @param name Nombre de la imagen
     * @return ruta absoluta de la imagen
     */
    private String urlOfImage(String name) {
        return System.getProperty("user.dir") + "\\src\\img\\" + name + ".png";
    }

    /**
     * Funcion de animacion y verificacion de impacto de los torpedos de un
     * submarino
     *
     * @param submarine Objeto submarino (actualPower)
     * @param codeCoords Coordenadas de la celda central (Celda seleccionada)
     * @param coords Lista de celdas en coordenas del submarino
     */
    private void submarineTorpedoes(Submarine submarine, String codeCoords, List<String> coords) {

        ScheduledFuture<?> task = scheduler.scheduleAtFixedRate(() -> {

            //Array de las cordenas de los torpedos
            String[] shootsCoords = (submarine.getTorpedoes().isEmpty())
                    ? new String[]{submarine.getPosition(), submarine.getPosition()}
                    : submarine.getTorpedoes().toArray(new String[0]);

            //Siente coordenada del torpedo
            String[] afterShoot = (submarine.getTorpedoes().isEmpty())
                    ? submarine.shoot(player.getCells()) : submarine.shoot(shootsCoords, enemy.getCells());

            // Código de la tarea a ejecutar
            boolean shoot0 = true;
            boolean shoot1 = true;
            //Verificar si se pasa de los limites el afterShoot
            if (!submarine.getOrientation()) {
                //1-10
                int af0 = Integer.parseInt(afterShoot[0].substring(1));
                int af1 = Integer.parseInt(afterShoot[1].substring(1));
                if (af0 < 1 || af0 > Size) {
                    shoot0 = false;
                }
                if (af1 < 1 || af1 > Size) {
                    shoot1 = false;
                }
            } else {
                //A-J
                char af0 = afterShoot[0].substring(0, 1).charAt(0);
                char af1 = afterShoot[1].substring(0, 1).charAt(0);
                if (!(af0 >= 'A' && af0 <= LAST_LETTER)) {
                    shoot0 = false;
                }
                if (!(af1 >= 'A' && af1 <= LAST_LETTER)) {
                    shoot1 = false;
                }
            }
            //se ejecuta el analizis de impacto
            //TODO: Verificar impacto con entidades

            if (shoot0 || shoot1) {

                //Posion anterior de torpedos
                if (!shootsCoords[0].equals(codeCoords)) {
                    submarine.setTorpedoes(shootsCoords);

                }
                //Validar si hay algun impacto en alguno de los lados
                if (submarine.verifyImpact(Arrays.asList(afterShoot), coords)) {
                    if (shoot0 && submarine.verifyImpact(afterShoot[0], coords)) {

                        shootsCoords[1] = afterShoot[1];
                        shoot0 = false;

                    }
                    if (shoot1 && submarine.verifyImpact(afterShoot[1], coords)) {
                        shootsCoords[0] = afterShoot[0];

                        shoot1 = false;
                    }
                } else {
                    //Nuevas coordenas
                    shootsCoords = afterShoot;
                }

                // shootsCoords a list
                List<String> shootList = Arrays.asList(shootsCoords);
                afterShoot = submarine.shoot(shootList);
                //Registrar coordenadas
                submarine.addCell(shootList);
                submarine.setTorpedoes(shootsCoords);
                //Cambiar icono por torpedo
                paintCells(true, shootList);
                player.addCell(shootList);
                //Cmabiar torpedo por impacto
                if (shoot0 == false) {
                    System.out.println("Impacto en 0");
                }
                if (shoot1 == false) {
                    System.out.println("Impacto en 1");
                }
            } else {
                System.out.println("Fin de los torpedos ");
                scheduler.shutdown();
                actualPowerUp = new Power();
                player.setTypeAttack(true);
            }

        }, 0, 1, TimeUnit.SECONDS);

    }

    /**
     * Maneja el evento de clic de una celda del tablero.
     *
     * @param Cell El botón de celda en el que se hizo clic.
     */
    private void PositionClick(JButton Cell) {
        //JButton Cell = (JButton) button.getComponent();
        if (actualBoat == null) {
            return;
        }
        String codeCoords = Cell.getName();
        List<String> coords = actualBoat.getSize() > 1 ? coordToCells(codeCoords) : Arrays.asList(codeCoords);
        if (validateCells(coords, player) && validateCellPosition(codeCoords)) {
            //Entidades de una celda
            player.addCell(coords);
            actualBoat.setCoords(coords);
            player.addBoat(actualBoat);
            paintCells(true, coords);
            //================PowerUp====================
            if (actualPowerUp instanceof Submarine) {
                Submarine submarine = (Submarine) actualPowerUp;
                //Establer posicion para atacar
                submarine.setPosition(codeCoords);
                //Verificar si el propio submario impacto algo
                if (submarine.verifyImpact(coords, enemy.getCells())) {
                    //TODO: Verificar impacto del submarina en las tre coordenadas de su ubicacion (validar si hay una mina)
                }
                submarine.addCell(codeCoords);

                //Ciclo de animacion y ejecucion de los torpedos
                submarineTorpedoes(submarine, codeCoords, coords);

                //TODO:Vaciar actualPowerUp
            } else if (actualPowerUp instanceof Locator) {
                //TODO:Logica de locator
            }
            //Cambiar de entidad
            changeEntity();
        }

    }

    /**
     * Estable las coordenadas de los bordes en sus respectivas listas
     */
    private void setBorders() {
        for (int i = 1; i <= Size; i++) {
            borderRight.add("A" + i);
            borderLeft.add(String.valueOf(LAST_LETTER) + i);
        }

        for (char letra = 'A'; letra <= LAST_LETTER; letra++) {
            borderTop.add(letra + "1");
            borderButton.add(letra + String.valueOf(Size));
        }
    }

    /**
     * Obtiene el botón de celda correspondiente al nombre especificado.
     *
     * @param name El nombre (Coordenada) del botón de celda que se desea
     * obtener.
     * @return El botón de celda correspondiente al nombre especificado.
     * @throws IllegalArgumentException si no se encuentra ningún botón con el
     * nombre especificado.
     */
    private JButton getCell(String name) {
        for (JButton bt : buttons) {
            if (bt.getName().equals(name)) {
                return bt;
            }
        }
        return new JButton();
    }

    /**
     * Convierte una coordenada en una lista de coordenadas cercanas, según las
     * reglas del juego para una entidad.
     *
     * @param coord La coordenada a convertir.
     * @return Una lista de coordenadas ocupadas por la entidad.
     */
    private List<String> coordToCells(String coord) {
        List<String> coords = new ArrayList<>();
        int num = Integer.parseInt(coord.substring(1));
        //Coordenas cercanas
        String coordLeft = ((char) (((int) coord.charAt(0)) - 1)) + "" + num;
        String coordRight = ((char) (((int) coord.charAt(0)) + 1)) + "" + num;
        String coordTop = coord.charAt(0) + "" + (num - 1);
        String coordButton = coord.charAt(0) + "" + (num + 1);
        if (inBuild) {
            if (player.getTypeAttack()) {
                int size = actualBoat.getSize();
                boolean orientation = actualBoat.getOrientation();
                //vert

                if (orientation) {
                    //horizo
                    if (size == 3) {
                        coords.add(coordTop);
                        coords.add(coord);
                        coords.add(coordButton);
                    } else {
                        coords.add(coord);
                        coords.add(coordButton);
                    }

                } else {
                    if (size == 3) {
                        coords.add(coordLeft);
                        coords.add(coord);
                        coords.add(coordRight);
                    } else {
                        coords.add(coord);
                        coords.add(coordRight);
                    }
                }
            } else {
                //Mine
                coords.add(coord);
            }
        } else if (player.getTypeAttack() == false) {
            if (actualPowerUp instanceof Locator) {
                /*
                0 1 2
                3 [4] 5
                6 7 8
                 */
                String coordLeftTop = ((char) (((int) coordTop.charAt(0)) - 1)) + "" + (num - 1);
                String coordRightTop = ((char) (((int) coordTop.charAt(0)) + 1)) + "" + (num - 1);
                String coordLeftButton = ((char) (((int) coordButton.charAt(0)) - 1)) + "" + (num + 1);
                String coordRightButton = ((char) (((int) coordButton.charAt(0)) + 1)) + "" + (num + 1);
                //asginar coordenadas
                //Arriba
                coords.add(coordLeftTop);
                coords.add(coordTop);
                coords.add(coordRightTop);
                //centro
                coords.add(coordLeft);
                coords.add(coord);
                coords.add(coordRight);
                //Abajo
                coords.add(coordLeftButton);
                coords.add(coordButton);
                coords.add(coordRightButton);

            } else if (actualPowerUp instanceof Submarine) {
                //Submarine
                if (((Submarine) actualPowerUp).getOrientation()) {
                    coords.add(coordTop);
                    coords.add(coord);
                    coords.add(coordButton);
                } else {
                    coords.add(coordLeft);
                    coords.add(coord);
                    coords.add(coordRight);
                }
            }
        }
        return coords;
    }

    /**
     * Borra las celdas fantasma del tablero, restaurando su apariencia original
     * a {@code VOID_CELL}.
     */
    private void clearGhostCells() {

        for (String cell : ghostCells) {
            getCell(cell).setIcon(VOID_CELL);
        }
        ghostCells = new ArrayList<>();
    }

    /**
     * Rota la imagen especificada por un ángulo dado.
     *
     * @param icon La imagen a rotar.
     * @param angle El ángulo de rotación en radianes.
     * @return Una nueva imagen rotada.
     */
    public ImageIcon rotateImage(ImageIcon icon, double angle) {
        Image image = icon.getImage();
        int w = image.getWidth(null);
        int h = image.getHeight(null);

        BufferedImage rotatedImage = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = rotatedImage.createGraphics();

        // Rotar la imagen 
        AffineTransform transform = new AffineTransform();
        transform.rotate(angle, w / 2, h / 2);
        g2d.setTransform(transform);
        g2d.drawImage(image, 0, 0, null);

        g2d.dispose();

        return new ImageIcon(rotatedImage);
    }

    /**
     * Obtiene un ImageIcon para un tipo específico de celda en función de
     * varios factores (tipo de barco, power up, etc).
     *
     * @param type El tipo de celda.
     * @param index El índice de la longitud de la entidad o parte espeficica
     * (10 para celda impactada, 0 - 2 Barcos y submarino, 8 y 9 Torpedos, 0 - 8
     * Localizador con 4 reservador para GPS).
     * @return Un ImageIcon para la celda especificada.
     */
    private ImageIcon getIcon(boolean type, int index) {

        StringBuilder typeOfImage = new StringBuilder();
        String url = "";
        //Imagen de impacto
        if (index == 10) {
            return new ImageIcon(urlOfImage("ZX"));
        }
        //Imagenes del bote actual
        if (index > 10 && index < 15) {
            //Le resto 11 al index para obtener el numero de imagen
            return rotateImage(new ImageIcon(urlOfImage((index - 11) + "")), actualBoat == null ? 0.0 : actualBoat.getRotationDegrees());
        }
        if (inBuild && player.getTypeAttack()) {
            //Validar si es un mina y powerUp esta activo

            //Obtener inicial
            String iniLetter = "";
            if (type && isPlayer) {
                iniLetter = "P";
            } else if (type && !isPlayer) {
                iniLetter = "X";
            }
            typeOfImage.append(iniLetter);
            //Siguientes letras
            typeOfImage.append(actualBoat.getSize() == 1 ? "B" : "H");
            url = typeOfImage.toString();
            int rotation = actualBoat.getRotation();
            switch (actualBoat.getSize()) {
                case 3 -> {
                    if (rotation >= 2) {
                        switch (index) {
                            case 0 ->
                                url += "C";
                            case 1 ->
                                url += "B";
                            default ->
                                url += "A";
                        }
                    } else {
                        switch (index) {
                            case 0 ->
                                url += "A";
                            case 1 ->
                                url += "B";
                            default ->
                                url += "C";
                        }
                    }
                }
                case 2 -> {

                    if (rotation >= 2) {
                        if (index == 0) {
                            url += "C";
                        } else {
                            url += "A";
                        }
                    } else {
                        if (index == 0) {
                            url += "A";
                        } else {
                            url += "C";
                        }
                    }
                }

            }
            return rotateImage(new ImageIcon(urlOfImage(url)), actualBoat.getRotationDegrees());

        } else if (inBuild && player.getTypeAttack() == false) {
            return new ImageIcon(urlOfImage("Mine"));
        } else {
            if (actualPowerUp instanceof Locator) {
                /*
                0 1 2
                3 [4] 5
                6 7 8
                 */
                url = "Locator";
                if (index != 4) {
                    url += "Cell";
                }
                return new ImageIcon(urlOfImage(url));
            } else if (actualPowerUp instanceof Submarine) {
                //Submarine
                url += (index < 3 ? "S" : "");
                if (((Submarine) actualPowerUp).getRotation() >= 2) {
                    switch (index) {
                        case 0 ->
                            url += "C";
                        case 1 ->
                            url += "B";
                        case 2 ->
                            url += "A";
                        default ->
                            url += "Torpedo";
                    }

                } else {
                    switch (index) {
                        case 0 ->
                            url += "A";
                        case 1 ->
                            url += "B";
                        case 2 ->
                            url += "C";
                        default ->
                            url += "Torpedo";
                    }
                }
            }
            if (index == 8) {
                return rotateImage(new ImageIcon(urlOfImage(url)), ((Submarine) actualPowerUp).getRotationDegreesTorpedoes()[0]);
            } else if (index == 9) {
                return rotateImage(new ImageIcon(urlOfImage(url)), ((Submarine) actualPowerUp).getRotationDegreesTorpedoes()[1]);
            }
            //Retorna submarine
            return rotateImage(new ImageIcon(urlOfImage(url)), ((Submarine) actualPowerUp).getRotationDegrees());
        }
    }

    /**
     * Este método se encarga de pintar las celdas del tablero según diferentes
     * condiciones, como el tipo de estado (ataque o jugada), la presencia de un
     * PowerUp activo y el tipo de PowerUp.
     *
     * @param type indica si se está pintando una celda real (true) o una celda
     * "fantasma" para previsualización (false).
     * @param cells lista de coordenadas de las celdas a pintar.
     */
    private void paintCells(boolean type, List<String> cells) {
        //Limpiar celdas
        clearGhostCells();
        //Pintar nuevas celdas
        if (inBuild) {

            if (player.getTypeAttack()) {
                //Boats
                switch (actualBoat.getSize()) {
                    case 3:
                        getCell(cells.get(0)).setIcon(getIcon(type, 0));
                        getCell(cells.get(1)).setIcon(getIcon(type, 1));
                        getCell(cells.get(2)).setIcon(getIcon(type, 2));
                        break;
                    case 2:
                        getCell(cells.get(0)).setIcon(getIcon(type, 0));
                        getCell(cells.get(1)).setIcon(getIcon(type, 1));
                        break;
                    case 1:
                        getCell(cells.get(0)).setIcon(getIcon(type, 0));
                        break;
                }
            } else {
                //Mine
                getCell(cells.get(0)).setIcon(getIcon(type, 0));

            }
        } else if (player.getTypeAttack() == false) {

            if (actualPowerUp instanceof Locator) {
                /*
                0 1 2
                3 [4] 5
                6 7 8
                 */
                for (int i = 0; i < cells.size(); i++) {
                    getCell(cells.get(i)).setIcon(getIcon(type, i));
                }

            } else if (actualPowerUp instanceof Submarine) {
                //Torpedo
                if (cells.size() == 2) {
                    Submarine sub = (Submarine) actualPowerUp;
                    if (!sub.getTorpedoes().isEmpty()) {
                        //Celdas antiguas
                        getCell(sub.getTorpedoes().get(0)).setIcon(getIcon(type, 8));
                        getCell(sub.getTorpedoes().get(1)).setIcon(getIcon(type, 8));
                    }
                    getCell(cells.get(0)).setIcon(getIcon(type, 8));
                    getCell(cells.get(1)).setIcon(getIcon(type, 9));
                } else {
                    //Submarino
                    getCell(cells.get(0)).setIcon(getIcon(type, 0));
                    getCell(cells.get(1)).setIcon(getIcon(type, 1));
                    getCell(cells.get(2)).setIcon(getIcon(type, 2));
                }
            } else {
                //Celda jugada
                getCell(cells.get(0)).setIcon(getIcon(type, 10));
            }
        }

        //Cambiar cells a ghost cells
        if (!type) {
            ghostCells = cells;
        }
    }

    /**
     * Este método se encarga de pintar las celdas del tablero como celdas
     * "fantasma" para previsualización.
     *
     * @param cells lista de coordenadas de las celdas a pintar.
     */
    private void paintCells(List<String> cells) {
        paintCells(false, cells);
    }

    /**
     * Metodo para limpiar visualmente todas las celdas
     */
    private void clearAllCells() {
        for (JButton button : buttons) {
            button.setIcon(VOID_CELL);
        }
    }

    /**
     * Este método se encarga de pintar una celda en el tablero.
     *
     * @param cell La coordenada de la celda a pintar.
     */
    private void paintCells(boolean type, String cell) {
        paintCells(type, Arrays.asList(cell));
    }

    /**
     * Valida si las celdas especificadas están disponibles para colocar un
     * barco. Comprueba si alguna de las celdas especificadas ya está ocupada
     * por otro barco.
     *
     * @param cells La lista de celdas a validar.
     * @return {@code true} si todas las celdas están disponibles, {@code false}
     * si al menos una celda está ocupada.
     */
    private boolean validateCells(List<String> cells, Player p) {
        for (String cell : cells) {
            if (p.getCells().contains(cell)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Valida si la posición de la celda especificada es válida para colocar una
     * entidad. Comprueba si la celda está dentro de los límites del tablero y
     * si es una posición válida para la orientación y tamaño de la entidad.
     *
     * @param cellName El nombre de la celda a validar.
     * @return {@code true} si la posición de la celda es válida, {@code false}
     * si la posición está fuera de los límites o no es adecuada para la entidad
     * actual.
     */
    private boolean validateCellPosition(String cellName) {
        boolean temp = false;
        if (inBuild && player.getTypeAttack() && actualBoat != null) {
            int longBoat = actualBoat.getSize();
            //false = horizontal, true = vertical
            boolean orientation = actualBoat.getOrientation();
            if (longBoat > 1) {
                if (orientation) {
                    //Botes horizontales
                    if (!borderButton.contains(cellName)) {
                        //Barcos de 3
                        if (longBoat == 3 && !borderTop.contains(cellName)) {
                            temp = true;
                        } else if (longBoat == 2) {
                            //Barcos de 2
                            temp = true;
                        }
                    }

                } else {
                    if (!borderRight.contains(cellName)) {
                        //Barcos de 3
                        if (longBoat == 3 && !borderLeft.contains(cellName)) {
                            temp = true;
                        } else if (longBoat == 2) {
                            //Barcos de 2
                            temp = true;
                        }
                    }
                }
            } else {
                temp = true;
            }
        } else if (player.getTypeAttack() == false && inBuild) {
            //Mine
            temp = true;
        } else {
            //Locator y submarine
            if (actualPowerUp instanceof Locator) {
                /*
                0 1 2
                3 [4] 5
                6 7 8
                 */

                if (!borderRight.contains(cellName) && !borderTop.contains(cellName) && !borderLeft.contains(cellName) && !borderButton.contains(cellName)) {
                    temp = true;
                }
            } else if (actualPowerUp instanceof Submarine) {
                if (((Submarine) actualPowerUp).getOrientation()) {

                    if (!borderButton.contains(cellName) && !borderTop.contains(cellName)) {
                        temp = true;

                    }

                } else {
                    if (!borderRight.contains(cellName) && !borderLeft.contains(cellName)) {
                        temp = true;

                    }
                }
            }
        }
        return temp;
    }

    /**
     * Cambia el turno entre el jugador y la computadora.
     *
     * Este método cambia el turno entre el jugador y la computadora en el
     * juego. Actualiza la variable de control `isPlayer` para reflejar quién
     * tiene el turno actual. Además, actualiza el tipo de ataque del jugador
     * actual, estableciéndolo como `true` si es el turno del jugador o como
     * `false` si es el turno de la computadora.
     *
     * Después de cambiar el turno, si el turno actual es de la computadora, se
     * realiza el ataque del enemigo llamando al método `enemyActtack()`.
     */
    private void turnChange() {
        System.out.println("Cambio de turno");
        isPlayer = !isPlayer;
        player.setTypeAttack(isPlayer);
        if (isPlayer) {
            //Jugador
        } else {
            //PC
            enemyActtack();
        }
    }

    /**
     * Muestra en el panel de información los datos del barco y una imagen de
     * este rotada segun el barco actual
     */
    private void displayBoatInformation() {
        if (actualBoat != null) {
            int index = 11;
            switch (actualBoat.getSize()) {
                case 1 ->
                    index = 12;
                case 2 ->
                    index = 13;
                case 3 ->
                    index = 14;
            }
            ImageBoat.setIcon(getIcon(true, index));
            L_Healtd.setText("Vida: " + actualBoat.getLife());
            String orient;
            orient = switch (actualBoat.getRotation()) {
                case 1 ->
                    "Norte";
                case 2 ->
                    "Este";
                case 3 ->
                    "Sur";
                default ->
                    "Oeste";
            };
            L_Orientation.setText("Orientación: " + orient);
            L_Size.setText("Tamaño: " + actualBoat.getSize());
        } else {
            ImageBoat.setIcon(new ImageIcon(urlOfImage("0")));
            L_Healtd.setText("Vida: ");
            L_Orientation.setText("Orientación: ");
            L_Size.setText("Tamaño: ");
        }
    }

    /**
     * Genera las coordenadas de los barcos para el jugador especificado. Borra
     * las celdas y la lista de barcos del jugador antes de generar las nuevas
     * coordenadas.
     *
     * @param tempPlayer El jugador para el cual generar las coordenadas de los
     * barcos.
     */
    private void generateCoordsOfBoats(Player tempPlayer) {
        clearAllCells();
        tempPlayer.clearCells();
        tempPlayer.clearBoatsList();
        Boat boat = new Boat();
        for (int type : entityList) {
            actualBoat = null;
            String coord = "";
            List<String> coordsList = new ArrayList<>();
            //Crea barco
            boat = new Boat(type);
            int rotation = getRandomNumber(3);
            boat.setRotation(rotation);
            boat.setOrientation((rotation == 1 || rotation == 3));
            actualBoat = boat;
            //Generar coordenadas
            boolean borders; //Resultado de si esta dentro o fuera de los limites
            do {
                coord = getRandomCoords(tempPlayer);
                coordsList = coordToCells(coord);
                borders = (!borderRight.contains(coord) && !borderTop.contains(coord) && !borderLeft.contains(coord) && !borderButton.contains(coord));

            } while (borders == false || validateCellPosition(coord) == false || validateCells(coordsList, tempPlayer) == false);

            //Establer coordenadas
            if (type == 1) {
                boat.setCoords(Arrays.asList(coord));
            } else if (type > 1 && type < 4) {
                boat.setCoords(coordsList);
            }
            tempPlayer.addBoat(boat);
            //Agergar celdas
            List<String> coordList = Arrays.asList(coord);
            tempPlayer.addCell(type > 1 ? coordsList : coordList);
            //Ver
            if (!tempPlayer.getName().equals("Bot")) {
                paintCells(true, type > 1 ? coordsList : coordList);
            }
            paintCells(true, type > 1 ? coordsList : coordList);

        }
        actualBoat = null;
        displayBoatInformation();
    }

    /**
     * Asigna la entidad actual y cambia a la siguiente:
     *
     * Si la lista de entidades no está vacía la copia y selecciona la primera
     * entidad. Si es una mina, establece el tipo de ataque del jugador como
     * falso y asigna la entidad. Si es un barco, crea una nueva instancia de
     * barco con el tipo correspondiente. Luego, elimina la entidad de la lista.
     *
     * Si la lista está vacía, inicia el juego estableciendo el tipo de ataque
     * del jugador como verdadero.
     */
    private void changeEntity() {
        displayBoatInformation();
        if (copyOfEntityList.isEmpty() && inBuild) {
            copyOfEntityList.addAll(entityList);
        }
        if (!copyOfEntityList.isEmpty()) {
            int actualEntity = copyOfEntityList.getFirst();
            //Mina
            if (actualEntity == 0) {
                System.out.println("Mina");
                player.setTypeAttack(false);
                actualPowerUp = new Mine();
            } else {
                actualBoat = new Boat(actualEntity);
            }
            //Elimino de la lista la entidad actual
            copyOfEntityList.removeFirst();
            if (copyOfEntityList.isEmpty()) {
                inBuild = false;
            }
        } else {
            System.out.println("Juego");
            //Limpio copyOfEntityList para ser usada en otros metodos
            copyOfEntityList.clear();
            actualBoat = null;
            actualPowerUp = null;
            //Inicia el juego
            player.setTypeAttack(true);
            System.out.println(player.getBoatList().toString());
            //IA vs Player
        }
    }

    /**
     * Genera un número entero aleatorio dentro del rango [min, max].
     *
     * @param min El valor mínimo del rango.
     * @param max El valor máximo del rango.
     * @return Un número entero aleatorio dentro del rango especificado.
     */
    private int getRandomNumber(int min, int max) {
        Random rand = new Random();
        return rand.nextInt(max - min + 1) + min;
    }

    /**
     * Genera un número entero aleatorio dentro del rango [0, max].
     *
     * @param max El valor máximo del rango.
     * @return Un número entero aleatorio dentro del rango especificado.
     */
    private int getRandomNumber(int max) {
        return getRandomNumber(0, max);
    }

    /**
     * Este metodo retorna una coordenada aleatoria no usada
     *
     * @param attackPlayer Objeto Player del jugador atacante
     * @param targetPlayer Objeto Player del jugador al que se va a atacar
     * @return Coordenada aleatoria, en caso de que todas las coordenadas fueron
     * usadas se retorna {@code null}
     */
    private String getRandomCoords(Player attackPlayer, Player targetPlayer) {
        if (attackPlayer.getCells().size() == (Size * Size)) {
            return null;
        }
        String coord = "";
        do {
            coord = getRandomCoords(attackPlayer);
        } while (targetPlayer.impactVerification(coord) == -1);
        return coord;
    }

    /**
     * Genera una coordenada aleatorias para el jugador especificado,
     * asegurándose de que no se hayan utilizado previamente.
     *
     * @param tempPlayer El jugador para el cual se generan las coordenadas.
     * @return Las coordenadas aleatorias generadas para el jugador.
     */
    private String getRandomCoords(Player tempPlayer) {
        StringBuilder coord = new StringBuilder();

        do {
            coord = new StringBuilder();
            char letter = (char) getRandomNumber((int) 'A', (int) LAST_LETTER);
            coord.append(letter).append(getRandomNumber(1, Size));
        } while (tempPlayer.getCells().contains(coord.toString()));
        return coord.toString();
    }

    /**
     * Metodo de dibujar impacto, registrando la coordenada usada
     *
     * @param boat Objeto barco a editar
     * @param coord Coordenada de impacto
     * @param tempPlayer Objeto Player (Jugador atacante actual del truno)
     */
    private void drawImpact(Boat boat, String coord, Player tempPlayer) {
        //Obtener indice de impacto
        int index = -1;
        for (int i = 0; i < boat.getCoords().size(); i++) {
            String tempCoords = boat.getCoords().get(i);
            if (tempCoords.equals(coord)) {
                index = i;
                break;
            }
        }
        //Registrar celda jugada en el jugadro actual
        tempPlayer.addCell(coord);
        actualBoat = boat;
        getCell(coord).setIcon(getIcon(true, index));
        actualBoat = null;
    }

    /**
     * Realiza un ataque por parte del enemigo.
     *
     * Este método implementa la lógica del ataque del enemigo en el juego.
     * Evalúa las estrategias de ataque dependiendo de la dificultad del juego y
     * las acciones disponibles del enemigo.
     *
     * Si existen celdas prioritarias para el enemigo y la dificultad es 2 (la
     * más alta), el enemigo intentará atacar esas celdas hasta que ya no haya
     * más barcos impactados.
     *
     * En caso contrario, si el enemigo tiene celdas disponibles para atacar,
     * intentará localizar y atacar barcos del oponente. Esto puede involucrar
     * el uso de estrategias específicas dependiendo de la dificultad del juego.
     * Si no hay celdas prioritarias definidas, el enemigo generará coordenadas
     * aleatorias para atacar.
     *
     * Una vez que se ha realizado el ataque, se verifica si se ha impactado un
     * barco del oponente y se realiza la actualización correspondiente en la
     * interfaz gráfica del juego. Luego, se realiza un cambio de turno.
     */
    private void enemyActtack() {
        StringBuilder coord = new StringBuilder();
        int idBoat = -1;
        actualPowerUp = null;
        if (!priorityCellsEnemy.isEmpty() && DIFICULTY == 2) {
            idBoat = player.impactVerification(priorityCellsEnemy.getFirst());
            priorityCellsEnemy.removeFirst();
            if (idBoat >= 0) {
                enemyActtack();
            }
        } //Validar un posicion anterior y analizar las celdas cercanas 
        else if (!enemy.getCells().isEmpty()) {
            //Reusar validacion de locator para validar limites para posible ataque
            actualPowerUp = new Locator();
            coord.append(enemy.getCells().get(getRandomNumber(enemy.getCells().size())));
            //Bucar un bote directamente
            if (DIFICULTY == 2 && getRandomNumber(10) > 3) {
                //Dejar solo minas
                copyOfEntityList.addAll(entityList);
                copyOfEntityList.removeIf(element -> element > 0);
                //posicion del ultimo bote
                int index = player.getBoatList().size() - (copyOfEntityList.size() * 2);
                //Establer coordenadas como prioritarias
                Boat boat = (Boat) player.getBoatList().get(index);
                priorityCellsEnemy.addAll(boat.getCoords());
                //Atacar coordenadas
                enemyActtack();
            }//Validar limites de coord
            else if (validateCellPosition(coord.toString())) {
                List<String> coords = coordToCells(coord.toString());
                //Dificultad normal
                if (DIFICULTY == 0) {
                    idBoat = player.impactVerification(coords.get(getRandomNumber(coords.size())));
                } else {

                    //Variable de dificultad aletoria
                    int dificulty = DIFICULTY == 1 ? getRandomNumber(3) : getRandomNumber(5, coords.size());
                    for (int i = 0; i < dificulty; i++) {
                        idBoat = player.impactVerification(coords.get(i));
                        if (DIFICULTY == 2) {
                            //El que perdona murio en la cruz
                            if (idBoat >= 0) {
                                Boat boat = player.getBoat(idBoat);
                                if (boat != null && !priorityCellsEnemy.containsAll(boat.getCoords())) {
                                    priorityCellsEnemy.addAll(boat.getCoords());
                                }
                            }
                        } else {
                            //Terminar bucle si pudo encontrar un bote
                            if (idBoat >= 0) {
                                break;
                            }
                        }
                    }
                    //Verficar si priorityCellsEnemy tiene alguna coordena de un barco, si no generar aleatoria
                    if (!priorityCellsEnemy.isEmpty()) {
                        enemyActtack();
                    } else {
                        //Generar coodenada aleatoria
                        String coordString = getRandomCoords(enemy, player);
                        if (!coordString.isEmpty()) {
                            idBoat = player.impactVerification(coordString);
                        }
                    }
                }

            } else {
                //Generar coodenada aleatoria
                String coordString = getRandomCoords(enemy, player);
                if (!coordString.isEmpty()) {
                    idBoat = player.impactVerification(coordString);
                }
            }
            actualPowerUp = null;
        } else {
            //Generar primera coordenada aleatoria
            idBoat = player.impactVerification(getRandomCoords(enemy, player));
        }
        //Validar si impacto un barco o no
        if (idBoat >= 0) {
            Boat boat = player.getBoat(idBoat);
            if (boat != null) {
                drawImpact(player.getBoat(idBoat), coord.toString(), enemy);
            }
        } else if (idBoat == -2) {
            getCell(coord.toString()).setIcon(getIcon(true, 10));
        } else if (idBoat == -3) {
            //Es una mina
        }
        turnChange();
    }

    /**
     * Obtiene la nueva posición de la rotación.
     *
     * @param rt El número de la rotación actual.
     * @return El nuevo número de la posición de la rotación.
     */
    private int getNewRotation(int rt) {
        if ((rt + 1) > 3) {
            return 0;
        }
        return rt + 1;
    }

    /**
     * Cambia la orientación de un barco en modo de construcción o la
     * orientación de un submarino en modo de ataque. Actualiza también la
     * rotación del barco o submarino.
     */
    private void changeRotation() {
        if (inBuild && actualBoat != null) {
            actualBoat.setOrientation(!actualBoat.getOrientation());
            int rotation = actualBoat.getRotation();
            actualBoat.setRotation(getNewRotation(rotation));
        } else if (player.getTypeAttack() == false && actualPowerUp instanceof Submarine) {
            Submarine temp = (Submarine) actualPowerUp;
            temp.setOrientation(!temp.getOrientation());
            int rt[] = {getNewRotation(temp.getRotationTorpedoes()[0]), getNewRotation(temp.getRotationTorpedoes()[1])};
            temp.setRotation(getNewRotation(temp.getRotation()));

            temp.setRotationTorpedoes(rt);
        }
    }

    /**
     * Maneja el evento de pasar el mouse sobre una celda en el tablero, para
     * dibujar el "fantasma" de la entidad.
     *
     * @param cellName El nombre de la celda sobre la que se ha pasado el mouse.
     */
    private void mouseHover(String cellName) {
        if (actualBoat == null) {
            return;
        }
        //Verificar que no este usada
        List<String> coords = (!(actualPowerUp instanceof Locator || actualPowerUp instanceof Submarine) || actualBoat.getSize() > 1) ? coordToCells(cellName) : Arrays.asList(cellName);
        if (validateCells(coords, player)) {
            //Para barcos de 2 y 3 celdas
            if (validateCellPosition(cellName)) {
                paintCells(coordToCells(cellName));
            } else {
                clearGhostCells();
            }

        }
    }

    /**
     * Devuelve las dimensiones totales del Jpanel, incluyendo el espacio del
     * panel y el espacio del tablero.
     *
     * @return Dimensiones totales del panel.
     */
    public Dimension getDimension() {
        return new Dimension(getDimensionCells().width + 196 + Gap, getDimensionCells().height);
    }

    /**
     * Devuelve las dimensiones del tablero de celdas.
     *
     * @return Dimensiones del tablero de celdas.
     */
    public Dimension getDimensionCells() {
        int r = (ButtonSize * Size) + ((Gap * 2) * (Size + 1));
        return new Dimension(r, r);
    }

    /**
     * Inicializa las celdas del panel con botones para representar el tablero
     * de juego.
     */
    private void initCells() {

        final String[] letters = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
            "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
            "U", "V", "W", "X", "Y", "Z"};

        final Dimension sizeButton = new Dimension(ButtonSize, ButtonSize);
        GridLayout gridLayout = new GridLayout(Size, Size);
        gridLayout.setHgap(Gap);
        gridLayout.setVgap(Gap);
        TablePanel.setLayout(gridLayout);
        for (int i = 0; i < Size; i++) {
            for (int j = 0; j < Size; j++) {
                String cellName = letters[j] + (i + 1);
                JButton cell = new JButton();
                cell.setName(cellName);
                cell.setSize(sizeButton);
                cell.setMaximumSize(sizeButton);
                cell.setMinimumSize(sizeButton);
                cell.addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        JButton clickedButton = (JButton) e.getSource();
                        // Acción a realizar cuando se hace clic en el botón
                        //System.out.println("Clic en la celda: " + clickedButton.getText());
                        PositionClick(clickedButton);
                    }
                });
                cell.addMouseListener(new MouseAdapter() {
                    @Override
                    public void mouseEntered(MouseEvent e) {
                        JButton enteredButton = (JButton) e.getSource();
                        // Acción a realizar cuando el mouse entra en el botón
                        // System.out.println("Mouse sobre la celda: " + enteredButton.getText());
                        mouseHover(enteredButton.getName());
                    }
                });
                //Agregar a lista JButton
                buttons.add(cell);
                cell.setIcon(VOID_CELL);
                cell.setBorderPainted(false);
                //Agregar boton al jpanel
                TablePanel.add(cell);
            }
        }
        //Nuevos tamanos
        this.setSize(getDimension());
        TablePanel.setSize(getDimensionCells());
        TablePanel.repaint();
    }
    private void rotateButtonMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_rotateButtonMouseClicked
        // TODO add your handling code here:
        changeRotation();
        displayBoatInformation();
    }//GEN-LAST:event_rotateButtonMouseClicked

    private void jButton2MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton2MouseClicked
        generateCoordsOfBoats(player);
    }//GEN-LAST:event_jButton2MouseClicked

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel ImageBoat;
    private javax.swing.JLabel L_Healtd;
    private javax.swing.JLabel L_Orientation;
    private javax.swing.JLabel L_Size;
    private javax.swing.JPanel Panel;
    private javax.swing.JPanel TablePanel;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JButton rotateButton;
    // End of variables declaration//GEN-END:variables
}
