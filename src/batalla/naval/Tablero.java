/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package batalla.naval;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import javax.swing.ImageIcon;
import javax.swing.JButton;

/**
 *
 * @author Jose
 */
public class Tablero extends javax.swing.JPanel {

    // Tamaño del tablero y espaciado entre celdas
    private int Size;
    private final int Gap = 6;
    private final int ButtonSize = 50;
    private char LAST_LETTER; // Última letra posible en el tablero

    // Indicadores de jugador y estado de construcción
    private boolean isPlayer; // Si es el jugador o enemigo
    private boolean inBuild; // Indica si se está construyendo el tablero

    // Jugadores y elementos del juego
    private Player player; // Jugador actual
    private Player enemy; // Jugador enemigo
    private Boat actualBoat; // Barco actualmente seleccionado
    private Power actualPowerUp; // PowerUp actualmente seleccionado

    // Lista de botones/elementos gráficos
    private List<JButton> buttons; // Lista de botones

    // Listas de bordes para validación de celdas
    private List<String> borderRight = new ArrayList<>();
    private List<String> borderLeft = new ArrayList<>();
    private List<String> borderTop = new ArrayList<>();
    private List<String> borderButton = new ArrayList<>();

    // Icono para celdas vacías
    private final ImageIcon VOID_CELL = new ImageIcon(System.getProperty("user.dir") + "\\src\\img\\Z.png");

    // Lista de celdas "fantasma" pintadas
    private List<String> ghostCells = new ArrayList<>();

    // Programación de tareas periódicas
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    /**
     * Constructor de Tablero
     *
     * @param Size Tamaño del tablero
     */
    public Tablero(int Size) {
        // Inicialización de variables
        this.Size = Size; // Tamaño del tablero
        this.LAST_LETTER = (char) ('A' + (Size - 1)); // Última letra en el tablero según el tamaño
        this.isPlayer = true; // Indica si es el turno del jugador
        this.inBuild = false; // Indica si se está construyendo el tablero
        this.buttons = new ArrayList<>(); // Lista de botones y elementos gráficos del tablero

        // Inicialización de jugadores y elementos del juego
        this.player = new Player(); // Jugador actual
        player.setTypeActtack(false); // Tipo de ataque del jugador
        this.actualBoat = new Boat(3); // Barco actualmente seleccionado
        this.enemy = new Player(); // Jugador enemigo
        this.actualPowerUp = new Submarine(); // PowerUp actualmente seleccionado

        // Inicialización de componentes gráficos y de juego
        initComponents(); // Inicializa los componentes gráficos del tablero
        initCells(); // Inicializa las celdas del tablero
        setBorders(); // Define los bordes del tablero para validación de celdas
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        Panel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        L_Healtd = new javax.swing.JLabel();
        L_Size = new javax.swing.JLabel();
        L_Orientation = new javax.swing.JLabel();
        rotateButton = new javax.swing.JButton();
        TablePanel = new javax.swing.JPanel();

        jButton1.setText("jButton1");

        setBackground(new java.awt.Color(204, 255, 255));
        setMinimumSize(new java.awt.Dimension(800, 600));
        setPreferredSize(new java.awt.Dimension(800, 600));

        Panel.setBackground(new java.awt.Color(255, 255, 255));

        jLabel1.setText("Barco actual:");

        jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 150, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 150, Short.MAX_VALUE)
        );

        L_Healtd.setText("Vida:");

        L_Size.setText("Tamaño:");

        L_Orientation.setText("Orientación:");

        rotateButton.setText("Rotar");
        rotateButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                rotateButtonMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout PanelLayout = new javax.swing.GroupLayout(Panel);
        Panel.setLayout(PanelLayout);
        PanelLayout.setHorizontalGroup(
            PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(PanelLayout.createSequentialGroup()
                .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(PanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel1))
                    .addGroup(PanelLayout.createSequentialGroup()
                        .addGap(27, 27, 27)
                        .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(L_Healtd)
                            .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(L_Size)
                            .addComponent(L_Orientation)
                            .addComponent(rotateButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addGap(0, 24, Short.MAX_VALUE))
        );
        PanelLayout.setVerticalGroup(
            PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(PanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(L_Healtd)
                .addGap(18, 18, 18)
                .addComponent(L_Size)
                .addGap(18, 18, 18)
                .addComponent(L_Orientation)
                .addGap(18, 18, 18)
                .addComponent(rotateButton, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(196, Short.MAX_VALUE))
        );

        TablePanel.setLayout(new java.awt.GridLayout());

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Panel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(TablePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(TablePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(Panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(95, 95, 95))
        );
    }// </editor-fold>//GEN-END:initComponents
    private String urlOfImage(String name) {
        return System.getProperty("user.dir") + "\\src\\img\\" + name + ".png";
    }

    /**
     * Funcion de animacion y verificacion de impacto de los torpedos de un
     * submarino
     *
     * @param submarine Objeto submarino (actualPower)
     * @param codeCoords Coordenadas de la celda central (Celda seleccionada)
     * @param coords Lista de celdas en coordenas del submarino
     */
    private void submarineTorpedoes(Submarine submarine, String codeCoords, List<String> coords) {

        ScheduledFuture<?> task = scheduler.scheduleAtFixedRate(() -> {

            //Array de las cordenas de los torpedos
            String[] shootsCoords = (submarine.getTorpedoes().isEmpty())
                    ? new String[]{submarine.getPosition(), submarine.getPosition()}
                    : submarine.getTorpedoes().toArray(new String[0]);

            //Siente coordenada del torpedo
            String[] afterShoot = (submarine.getTorpedoes().isEmpty())
                    ? submarine.shoot(player.getCells()) : submarine.shoot(shootsCoords, enemy.getCells());

            // Código de la tarea a ejecutar
            boolean shoot0 = true;
            boolean shoot1 = true;
            //Verificar si se pasa de los limites el afterShoot
            if (!submarine.getOrientation()) {
                //1-10
                int af0 = Integer.parseInt(afterShoot[0].substring(1));
                int af1 = Integer.parseInt(afterShoot[1].substring(1));
                if (af0 < 1 || af0 > Size) {
                    shoot0 = false;
                }
                if (af1 < 1 || af1 > Size) {
                    shoot1 = false;
                }
            } else {
                //A-J
                char af0 = afterShoot[0].substring(0, 1).charAt(0);
                char af1 = afterShoot[1].substring(0, 1).charAt(0);
                if (!(af0 >= 'A' && af0 <= LAST_LETTER)) {
                    shoot0 = false;
                }
                if (!(af1 >= 'A' && af1 <= LAST_LETTER)) {
                    shoot1 = false;
                }
            }
            //se ejecuta el analizis de impacto
            //TODO: Verificar impacto con entidades

            if (shoot0 || shoot1) {

                //Posion anterior de torpedos
                if (!shootsCoords[0].equals(codeCoords)) {
                    submarine.setTorpedoes(shootsCoords);

                }
                //Validar si hay algun impacto en alguno de los lados
                if (submarine.verifyImpact(Arrays.asList(afterShoot), coords)) {
                    if (shoot0 && submarine.verifyImpact(afterShoot[0], coords)) {

                        shootsCoords[1] = afterShoot[1];
                        shoot0 = false;

                    }
                    if (shoot1 && submarine.verifyImpact(afterShoot[1], coords)) {
                        shootsCoords[0] = afterShoot[0];

                        shoot1 = false;
                    }
                } else {
                    //Nuevas coordenas
                    shootsCoords = afterShoot;
                }

                // shootsCoords a list
                List<String> shootList = Arrays.asList(shootsCoords);
                afterShoot = submarine.shoot(shootList);
                //Registrar coordenadas
                submarine.addCell(shootList);
                submarine.setTorpedoes(shootsCoords);
                //Cambiar icono por torpedo
                paintCells(true, shootList);
                player.addCell(shootList);
                //Cmabiar torpedo por impacto
                if (shoot0 == false) {
                    System.out.println("Impacto en 0");
                }
                if (shoot1 == false) {
                    System.out.println("Impacto en 1");
                }
            } else {
                System.out.println("Fin de los torpedos ");
                scheduler.shutdown();
                actualPowerUp = new Power();
                player.setTypeActtack(true);
            }

        }, 0, 1, TimeUnit.SECONDS);

    }

    /**
     * Maneja el evento de clic de una celda del tablero.
     *
     * @param Cell El botón de celda en el que se hizo clic.
     */
    private void PositionClick(JButton Cell) {
        //JButton Cell = (JButton) button.getComponent();
        String codeCoords = Cell.getName();
        List<String> coords = actualBoat.getSize() > 1 ? entityToCells(codeCoords) : Arrays.asList(codeCoords);
        if (validateCells(coords) && validateCellPosition(codeCoords)) {
            //Entidades de una celda
            player.addCell(coords);
            actualBoat.setCoords(coords);
            player.addBoat(actualBoat);
            paintCells(true, coords);
            //================PowerUp====================
            if (actualPowerUp instanceof Submarine) {
                Submarine submarine = (Submarine) actualPowerUp;
                //Establer posicion para atacar
                submarine.setPosition(codeCoords);
                //Verificar si el propio submario impacto algo
                if (submarine.verifyImpact(coords, enemy.getCells())) {
                    //TODO: Verificar impacto del submarina en las tre coordenadas de su ubicacion (validar si hay una mina)
                }
                submarine.addCell(codeCoords);

                //Ciclo de animacion y ejecucion de los torpedos
                submarineTorpedoes(submarine, codeCoords, coords);

                //TODO:Vaciar actualPowerUp
            } else if (actualPowerUp instanceof Locator) {
                //TODO:Logica de locator
            }
        }

    }

    /**
     * Estable las coordenadas de los bordes en sus respectivas listas
     */
    private void setBorders() {
        for (int i = 1; i <= Size; i++) {
            borderRight.add("A" + i);
            borderLeft.add(String.valueOf(LAST_LETTER) + i);
        }

        for (char letra = 'A'; letra <= LAST_LETTER; letra++) {
            borderTop.add(letra + "1");
            borderButton.add(letra + String.valueOf(Size));
        }

    }

    /**
     * Obtiene el botón de celda correspondiente al nombre especificado.
     *
     * @param name El nombre (Coordenada) del botón de celda que se desea
     * obtener.
     * @return El botón de celda correspondiente al nombre especificado.
     * @throws IllegalArgumentException si no se encuentra ningún botón con el
     * nombre especificado.
     */
    private JButton getCell(String name) {
        for (JButton bt : buttons) {
            if (bt.getName().equals(name)) {
                return bt;
            }
        }
        throw new IllegalArgumentException("No se encontró ningún botón con el nombre especificado: " + name);
    }

    /**
     * Convierte una coordenada en una lista de coordenadas cercanas, según las
     * reglas del juego para una entidad.
     *
     * @param coord La coordenada a convertir.
     * @return Una lista de coordenadas ocupadas por la entidad.
     */
    private List<String> entityToCells(String coord) {
        List<String> coords = new ArrayList<>();
        int num = Integer.parseInt(coord.substring(1));
        //Coordenas cercanas
        String coordLeft = ((char) (((int) coord.charAt(0)) - 1)) + "" + num;
        String coordRight = ((char) (((int) coord.charAt(0)) + 1)) + "" + num;
        String coordTop = coord.charAt(0) + "" + (num - 1);
        String coordButton = coord.charAt(0) + "" + (num + 1);
        if (inBuild) {
            if (player.getTypeActtack()) {
                int size = actualBoat.getSize();
                boolean orientation = actualBoat.getOrientation();
                //vert

                if (orientation) {
                    //horizo
                    if (size == 3) {
                        coords.add(coordTop);
                        coords.add(coord);
                        coords.add(coordButton);
                    } else {
                        coords.add(coord);
                        coords.add(coordButton);
                    }

                } else {
                    if (size == 3) {
                        coords.add(coordLeft);
                        coords.add(coord);
                        coords.add(coordRight);
                    } else {
                        coords.add(coord);
                        coords.add(coordRight);
                    }
                }
            } else {
                //Mine
                coords.add(coord);
            }
        } else if (player.getTypeActtack() == false) {
            if (actualPowerUp instanceof Locator) {
                /*
                0 1 2
                3 [4] 5
                6 7 8
                 */
                String coordLeftTop = ((char) (((int) coordTop.charAt(0)) - 1)) + "" + (num - 1);
                String coordRightTop = ((char) (((int) coordTop.charAt(0)) + 1)) + "" + (num - 1);
                String coordLeftButton = ((char) (((int) coordButton.charAt(0)) - 1)) + "" + (num + 1);
                String coordRightButton = ((char) (((int) coordButton.charAt(0)) + 1)) + "" + (num + 1);
                //asginar coordenadas
                //Arriba
                coords.add(coordLeftTop);
                coords.add(coordTop);
                coords.add(coordRightTop);
                //centro
                coords.add(coordLeft);
                coords.add(coord);
                coords.add(coordRight);
                //Abajo
                coords.add(coordLeftButton);
                coords.add(coordButton);
                coords.add(coordRightButton);

            } else if (actualPowerUp instanceof Submarine) {
                //Submarine
                if (((Submarine) actualPowerUp).getOrientation()) {
                    coords.add(coordTop);
                    coords.add(coord);
                    coords.add(coordButton);
                } else {
                    coords.add(coordLeft);
                    coords.add(coord);
                    coords.add(coordRight);
                }
            }
        }
        return coords;
    }

    /**
     * Borra las celdas fantasma del tablero, restaurando su apariencia original
     * a {@code VOID_CELL}.
     */
    private void clearGhostCells() {

        for (String cell : ghostCells) {
            getCell(cell).setIcon(VOID_CELL);
        }
        ghostCells = new ArrayList<>();
    }

    /**
     * Rota la imagen especificada por un ángulo dado.
     *
     * @param icon La imagen a rotar.
     * @param angle El ángulo de rotación en radianes.
     * @return Una nueva imagen rotada.
     */
    public ImageIcon rotateImage(ImageIcon icon, double angle) {
        Image image = icon.getImage();
        int w = image.getWidth(null);
        int h = image.getHeight(null);

        BufferedImage rotatedImage = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = rotatedImage.createGraphics();

        // Rotar la imagen 
        AffineTransform transform = new AffineTransform();
        transform.rotate(angle, w / 2, h / 2);
        g2d.setTransform(transform);
        g2d.drawImage(image, 0, 0, null);

        g2d.dispose();

        return new ImageIcon(rotatedImage);
    }

    /**
     * Obtiene un ImageIcon para un tipo específico de celda en función de
     * varios factores (tipo de barco, power up, etc).
     *
     * @param type El tipo de celda.
     * @param index El índice de la longitud de la entidad o parte espeficica
     * (Mayores a 10 para celda impactada, 0 - 2 Barcos y submarino, 8 y 9
     * Torpedos, 0 - 8 Localizador con 4 reservador para GPS).
     * @return Un ImageIcon para la celda especificada.
     */
    private ImageIcon getIcon(boolean type, int index) {

        StringBuilder typeOfImage = new StringBuilder();
        String url = "";
        if (index > 10) {
            return new ImageIcon(urlOfImage("ZX"));
        }
        if (inBuild && player.getTypeActtack()) {
            //Validar si es un mina y powerUp esta activo

            typeOfImage.append(type ? "" : "P");
            typeOfImage.append(actualBoat.getSize() == 1 ? "B" : "H");
            url = typeOfImage.toString();
            int rotation = actualBoat.getRotation();
            switch (actualBoat.getSize()) {
                case 3 -> {
                    if (rotation >= 2) {
                        switch (index) {
                            case 0 ->
                                url += "C";
                            case 1 ->
                                url += "B";
                            default ->
                                url += "A";
                        }
                    } else {
                        switch (index) {
                            case 0 ->
                                url += "A";
                            case 1 ->
                                url += "B";
                            default ->
                                url += "C";
                        }
                    }
                }
                case 2 -> {

                    if (rotation >= 2) {
                        if (index == 0) {
                            url += "C";
                        } else {
                            url += "A";
                        }
                    } else {
                        if (index == 0) {
                            url += "A";
                        } else {
                            url += "C";
                        }
                    }
                }

            }
            return rotateImage(new ImageIcon(urlOfImage(url)), actualBoat.getRotationDegrees());

        } else if (inBuild && player.getTypeActtack() == false) {
            return new ImageIcon(urlOfImage("Mine"));
        } else {
            if (actualPowerUp instanceof Locator) {
                /*
                0 1 2
                3 [4] 5
                6 7 8
                 */
                url = "Locator";
                if (index != 4) {
                    url += "Cell";
                }
                return new ImageIcon(urlOfImage(url));
            } else if (actualPowerUp instanceof Submarine) {
                //Submarine
                url += (index < 3 ? "S" : "");
                if (((Submarine) actualPowerUp).getRotation() >= 2) {
                    switch (index) {
                        case 0 ->
                            url += "C";
                        case 1 ->
                            url += "B";
                        case 2 ->
                            url += "A";
                        default ->
                            url += "Torpedo";
                    }

                } else {
                    switch (index) {
                        case 0 ->
                            url += "A";
                        case 1 ->
                            url += "B";
                        case 2 ->
                            url += "C";
                        default ->
                            url += "Torpedo";
                    }
                }
            }
            if (index == 8) {
                return rotateImage(new ImageIcon(urlOfImage(url)), ((Submarine) actualPowerUp).getRotationDegreesTorpedoes()[0]);
            } else if (index == 9) {
                return rotateImage(new ImageIcon(urlOfImage(url)), ((Submarine) actualPowerUp).getRotationDegreesTorpedoes()[1]);
            }
            //Retorna submarine
            return rotateImage(new ImageIcon(urlOfImage(url)), ((Submarine) actualPowerUp).getRotationDegrees());
        }
    }

    /**
     * Este método se encarga de pintar las celdas del tablero según diferentes
     * condiciones, como el tipo de estado (ataque o jugada), la presencia de un
     * PowerUp activo y el tipo de PowerUp.
     *
     * @param type indica si se está pintando una celda real (true) o una celda
     * "fantasma" para previsualización (false).
     * @param cells lista de coordenadas de las celdas a pintar.
     */
    private void paintCells(boolean type, List<String> cells) {
        //Limpiar celdas
        clearGhostCells();
        //Pintar nuevas celdas
        if (inBuild) {

            if (player.getTypeActtack()) {
                //Boats
                switch (actualBoat.getSize()) {
                    case 3:
                        getCell(cells.get(0)).setIcon(getIcon(type, 0));
                        getCell(cells.get(1)).setIcon(getIcon(type, 1));
                        getCell(cells.get(2)).setIcon(getIcon(type, 2));
                        break;
                    case 2:
                        getCell(cells.get(0)).setIcon(getIcon(type, 0));
                        getCell(cells.get(1)).setIcon(getIcon(type, 1));
                        break;
                    case 1:
                        getCell(cells.get(0)).setIcon(getIcon(type, 0));
                        break;
                }
            } else {
                //Mine
                getCell(cells.get(0)).setIcon(getIcon(type, 0));

            }
        } else if (player.getTypeActtack() == false) {

            if (actualPowerUp instanceof Locator) {
                /*
                0 1 2
                3 [4] 5
                6 7 8
                 */
                for (int i = 0; i < cells.size(); i++) {
                    getCell(cells.get(i)).setIcon(getIcon(type, i));
                }

            } else if (actualPowerUp instanceof Submarine) {
                //Torpedo
                if (cells.size() == 2) {
                    Submarine sub = (Submarine) actualPowerUp;
                    if (!sub.getTorpedoes().isEmpty()) {
                        //Celdas antiguas
                        getCell(sub.getTorpedoes().get(0)).setIcon(getIcon(type, 8));
                        getCell(sub.getTorpedoes().get(1)).setIcon(getIcon(type, 8));
                    }
                    getCell(cells.get(0)).setIcon(getIcon(type, 8));
                    getCell(cells.get(1)).setIcon(getIcon(type, 9));
                } else {
                    //Submarino
                    getCell(cells.get(0)).setIcon(getIcon(type, 0));
                    getCell(cells.get(1)).setIcon(getIcon(type, 1));
                    getCell(cells.get(2)).setIcon(getIcon(type, 2));
                }
            }
        }

        //Cambiar cells a ghost cells
        if (!type) {
            ghostCells = cells;
        }
    }

    /**
     * Este método se encarga de pintar las celdas del tablero como celdas
     * "fantasma" para previsualización.
     *
     * @param cells lista de coordenadas de las celdas a pintar.
     */
    private void paintCells(List<String> cells) {
        paintCells(false, cells);
    }

    /**
     * Este método se encarga de pintar una celda del tablero como una celda
     * "fantasma" para previsualización.
     *
     * @param cell La coordenada de la celda a pintar.
     */
    private void paintCells(String cell) {
        paintCells(false, Arrays.asList(cell));
    }

    /**
     * Valida si las celdas especificadas están disponibles para colocar un
     * barco. Comprueba si alguna de las celdas especificadas ya está ocupada
     * por otro barco.
     *
     * @param cells La lista de celdas a validar.
     * @return {@code true} si todas las celdas están disponibles, {@code false}
     * si al menos una celda está ocupada.
     */
    private boolean validateCells(List<String> cells) {
        for (String cell : cells) {
            if (player.getCells().contains(cell)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Valida si la posición de la celda especificada es válida para colocar una
     * entidad. Comprueba si la celda está dentro de los límites del tablero y
     * si es una posición válida para la orientación y tamaño de la entidad.
     *
     * @param cellName El nombre de la celda a validar.
     * @return {@code true} si la posición de la celda es válida, {@code false}
     * si la posición está fuera de los límites o no es adecuada para la entidad
     * actual.
     */
    private boolean validateCellPosition(String cellName) {
        boolean temp = false;
        if (inBuild && player.getTypeActtack()) {
            int longBoat = actualBoat.getSize();
            //false = horizontal, true = vertical
            boolean orientation = actualBoat.getOrientation();
            if (longBoat > 1) {
                if (orientation) {
                    //Botes horizontales
                    if (!borderButton.contains(cellName)) {
                        //Barcos de 3
                        if (longBoat == 3 && !borderTop.contains(cellName)) {
                            temp = true;
                        } else if (longBoat == 2) {
                            //Barcos de 2
                            temp = true;
                        }
                    }

                } else {
                    if (!borderRight.contains(cellName)) {
                        //Barcos de 3
                        if (longBoat == 3 && !borderLeft.contains(cellName)) {
                            temp = true;
                        } else if (longBoat == 2) {
                            //Barcos de 2
                            temp = true;
                        }
                    }
                }
            } else {
                temp = true;
            }
        } else if (player.getTypeActtack() == false && inBuild) {
            //Mine
            temp = true;
        } else {
            //Locator y submarine
            if (actualPowerUp instanceof Locator) {
                /*
                0 1 2
                3 [4] 5
                6 7 8
                 */

                if (!borderRight.contains(cellName) && !borderTop.contains(cellName) && !borderLeft.contains(cellName) && !borderButton.contains(cellName)) {
                    temp = true;
                }
            } else if (actualPowerUp instanceof Submarine) {
                if (((Submarine) actualPowerUp).getOrientation()) {

                    if (!borderButton.contains(cellName) && !borderTop.contains(cellName)) {
                        temp = true;

                    }

                } else {
                    if (!borderRight.contains(cellName) && !borderLeft.contains(cellName)) {
                        temp = true;

                    }
                }
            }
        }
        return temp;
    }

    /**
     * Obtiene la nueva posición de la rotación.
     *
     * @param rt El número de la rotación actual.
     * @return El nuevo número de la posición de la rotación.
     */
    private int getNewRotation(int rt) {
        if ((rt + 1) > 3) {
            return 0;
        }
        return rt + 1;
    }

    /**
     * Cambia la orientación de un barco en modo de construcción o la
     * orientación de un submarino en modo de ataque. Actualiza también la
     * rotación del barco o submarino.
     */
    private void changeRotation() {
        if (inBuild) {
            actualBoat.setOrientation(!actualBoat.getOrientation());
            int rotation = actualBoat.getRotation();
            actualBoat.setRotation(getNewRotation(rotation));

        } else if (player.getTypeActtack() == false && actualPowerUp instanceof Submarine) {
            Submarine temp = (Submarine) actualPowerUp;
            temp.setOrientation(!temp.getOrientation());
            int rt[] = {getNewRotation(temp.getRotationTorpedoes()[0]), getNewRotation(temp.getRotationTorpedoes()[1])};
            temp.setRotation(getNewRotation(temp.getRotation()));

            temp.setRotationTorpedoes(rt);
        }
    }

    /**
     * Maneja el evento de pasar el mouse sobre una celda en el tablero, para
     * dibujar el "fantasma" de la entidad.
     *
     * @param cellName El nombre de la celda sobre la que se ha pasado el mouse.
     */
    private void mouseHover(String cellName) {
        //String cellName = mouse.getComponent().getName();
        //Verificar que no este usada
        List<String> coords = (!(actualPowerUp instanceof Locator || actualPowerUp instanceof Submarine) || actualBoat.getSize() > 1) ? entityToCells(cellName) : Arrays.asList(cellName);
        if (validateCells(coords)) {
            //Para barcos de 2 y 3 celdas
            if (validateCellPosition(cellName)) {
                paintCells(entityToCells(cellName));
            } else {
                clearGhostCells();
            }

        }
    }

    /**
     * Devuelve las dimensiones totales del Jpanel, incluyendo el espacio del
     * panel y el espacio del tablero.
     *
     * @return Dimensiones totales del panel.
     */
    public Dimension getDimension() {
        return new Dimension(getDimensionCells().width + 203 + Gap, getDimensionCells().height);
    }

    /**
     * Devuelve las dimensiones del tablero de celdas.
     *
     * @return Dimensiones del tablero de celdas.
     */
    public Dimension getDimensionCells() {
        int r = (ButtonSize * Size) + (Gap * (Size + 1));
        return new Dimension(r, r);
    }

    /**
     * Inicializa las celdas del panel con botones para representar el tablero
     * de juego.
     */
    private void initCells() {

        final String[] letters = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
            "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
            "U", "V", "W", "X", "Y", "Z"};

        final Dimension sizeButton = new Dimension(ButtonSize, ButtonSize);
        GridLayout gridLayout = new GridLayout(Size, Size);
        gridLayout.setHgap(Gap);
        gridLayout.setVgap(Gap);
        TablePanel.setLayout(gridLayout);
        for (int i = 0; i < Size; i++) {
            for (int j = 0; j < Size; j++) {
                String cellName = letters[j] + (i + 1);
                JButton cell = new JButton();
                cell.setName(cellName);
                cell.setSize(sizeButton);
                cell.setMaximumSize(sizeButton);
                cell.setMinimumSize(sizeButton);
                cell.addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        JButton clickedButton = (JButton) e.getSource();
                        // Acción a realizar cuando se hace clic en el botón
                        //System.out.println("Clic en la celda: " + clickedButton.getText());
                        PositionClick(clickedButton);
                    }
                });
                cell.addMouseListener(new MouseAdapter() {
                    @Override
                    public void mouseEntered(MouseEvent e) {
                        JButton enteredButton = (JButton) e.getSource();
                        // Acción a realizar cuando el mouse entra en el botón
                        // System.out.println("Mouse sobre la celda: " + enteredButton.getText());
                        mouseHover(enteredButton.getName());
                    }
                });
                //Agregar a lista JButton
                buttons.add(cell);
                cell.setIcon(VOID_CELL);
                cell.setBorderPainted(false);
                //Agregar boton al jpanel
                TablePanel.add(cell);
            }
        }
        //Nuevos tamanos
        this.setSize(getDimension());
        System.out.println(getDimension());
        System.out.println(getDimensionCells());
        TablePanel.setSize(getDimensionCells());
        TablePanel.repaint();
    }
    private void rotateButtonMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_rotateButtonMouseClicked
        // TODO add your handling code here:
        changeRotation();

    }//GEN-LAST:event_rotateButtonMouseClicked

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel L_Healtd;
    private javax.swing.JLabel L_Orientation;
    private javax.swing.JLabel L_Size;
    private javax.swing.JPanel Panel;
    private javax.swing.JPanel TablePanel;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JButton rotateButton;
    // End of variables declaration//GEN-END:variables
}
